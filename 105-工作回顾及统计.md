```dataviewjs
// ===【正确排序修复版】结合统计功能与正确排序 ===

// ===【1】获取所有任务 ===
const allTasks = dv.pages('#周报')
	.where(p=>p.file.name!="周报模板")
	.file.tasks;

// ===【2】使用分组排序方法确保正确排序 ===
// 将任务分为两组：有时间戳的和无时间戳的
const tasksWithTimestamps = [];
const tasksWithoutTimestamps = [];

allTasks.forEach(task => {
    const taskText = task.text || '';
    const timeMatch = taskText.match(/✅\s*(\d{4}-\d{2}-\d{2})/);

    if (timeMatch) {
        tasksWithTimestamps.push({
            task: task,
            timestamp: timeMatch[1],
            date: new Date(timeMatch[1])
        });
    } else {
        tasksWithoutTimestamps.push(task);
    }
});

// 对有时间戳的任务按时间倒序排序（最近的在前）
tasksWithTimestamps.sort((a, b) => {
    return b.date.getTime() - a.date.getTime();
});

// 将排序后的任务合并
const sortedTasks = [
    ...tasksWithTimestamps.map(item => item.task), // 有时间戳的任务（按时间倒序）
    ...tasksWithoutTimestamps // 无时间戳的任务（保持原顺序）
];

// ===【3】统计【】标签计数 ===
const tasksText = sortedTasks.map(t=>t.text);   // 纯文本数组
const reg = /【([^【】]+)】/g;
const counter = {};
tasksText.forEach(text=>{
	let m; while((m=reg.exec(text))!==null){
		const tag = m[1].trim();
		counter[tag] = (counter[tag]||0)+1;
	}
});

//添加标签按钮并显示出来，对应以上统计的所有标签。点击按钮，筛选出对应标签的任务。
const tagButtons = document.createElement('div');
tagButtons.classList.add('tag-buttons');
dv.container.appendChild(tagButtons);
Object.entries(counter).forEach(([tag, count])=>{
    const button = document.createElement('button');
    button.textContent = `${tag} (${count})`;
    // 添加筛选类和数据属性，与现有筛选逻辑统一
    button.className = 'tag-filter';
    button.dataset.tag = tag;
    tagButtons.appendChild(button);
});

// ===【4】表格 + 百分比 + 彩色动态进度条（已修复） ===
const rows = Object.entries(counter).sort((a, b) => b[1] - a[1]);
const total = rows.reduce((s, r) => s + r[1], 0);

// 生成样式字符串
const styleText = `
  /* 强制最外层渲染层吃字体大小 */
  .markdown-rendered .dataview.table-view-table{
      font-size:20px !important;
      font-weight: bold !important;
  }
  .markdown-rendered .dataview.table-view-table thead th{
      font-size:20px !important;
      font-weight:700 !important;
  }
  /* 列宽保持 */
  .markdown-rendered .dataview.table-view-table td:nth-child(1){
      max-width:344px !important;
      width:344px !important;
      white-space:nowrap !important;
      overflow:hidden !important;
      text-overflow:ellipsis !important;
  }
  .markdown-rendered .dataview.table-view-table td:nth-child(3){
      min-width:120px !important;
  }
  /* 标签按钮样式 */
  .tag-buttons {
      margin-bottom: 15px;
      display: flex;
      gap: 8px;
  }
  .tag-filter {
      padding: 6px 12px;
      background-color: #007bff;
      color: white;
      border-radius: 4px;
      text-decoration: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
  }
.tag-filter {
    transition: all 0.3s ease;
}

.tag-filter:active {
    transform: scale(0.95);
    filter: brightness(1.2);
}
`;

// 创建 <style> 并塞进 shadow DOM
const id = 'dv-big-font';
let styleEl = document.getElementById(id);
if (!styleEl) {
  styleEl = document.createElement('style');
  styleEl.id = id;
  styleEl.textContent = styleText;
  // 向上找到 shadow host 并插入
  const host = dv.container.closest('.markdown-rendered') || dv.container;
  host.appendChild(styleEl);
}

const tableRows = rows.map(([tag, cnt]) => {
    const pct = Math.round(cnt / total * 100);

    let color = "#9ca3af"; // 默认灰色
    if (pct >= 70)      color = "#ef4444"; // 红
    else if (pct >= 30) color = "#f59e0b"; // 橙
    else if (pct >= 10) color = "#10b981"; // 绿

    // --- 这是修改的核心部分 ---
    // 使用 linear-gradient 创建进度条背景，结构更简单
    const progressBar = dv.span(`<div style="
        position: relative;
        height: 16px;
        border-radius: 8px;
        overflow: hidden;
        background: linear-gradient(to right, ${color} ${pct}%, #e5e7eb ${pct}%);
        width: 100%;
    ">
        <div style="
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 16px;
            mix-blend-mode: difference;     /* 关键一行，反转色 */
        ">
            ${pct}%
        </div>
    </div>`);

	// 将标签链接替换为普通文本
	const tagLink = dv.span(`<span class="tag-filter" data-tag="${tag}">${tag}</span>`);

	return [tagLink, cnt, progressBar];
});

dv.table(["标签", "次数", "占比"], tableRows);

/******************************************************************
 * 【5】统一容器渲染任务列表（使用正确排序的任务）
 ******************************************************************/
(async () => {
    try {
        const taskHtml = await dv.taskList(sortedTasks, false); // 使用正确排序的任务

        // 如果 taskHtml 为空或 undefined，提供默认内容
        if (!taskHtml || taskHtml.trim() === '') {
            dv.span(`<div id="tagReportWrap">
                <div id="taskContainer"><p>暂无任务</p></div>
            </div>`);
        } else {
            dv.span(`<div id="tagReportWrap">
                <div class="tag-buttons">
                    <a href="#" class="tag-filter" data-tag="All">全部</a>
                    <a href="#" class="tag-filter" data-tag="工作">工作</a>
                    <a href="#" class="tag-filter" data-tag="个人">个人</a>
                    <a href="#" class="tag-filter" data-tag="项目">项目</a>
                </div>
                <div id="taskContainer">${taskHtml}</div>
            </div>`);
        }
    } catch (error) {
        dv.span(`<div id="tagReportWrap">
            <div id="taskContainer"><p>加载任务失败，请稍后重试。</p></div>
        </div>`);
    }
})();

/******************************************************************
 * 【6】给每个 <li> 打上 data-tags（就在同一个容器里操作）
 ******************************************************************/
setTimeout(() => {
    const wrap = dv.container.querySelector('#tagReportWrap') || dv.container;
    wrap.querySelectorAll('#taskContainer li').forEach(li => {
        const txt  = li.textContent || '';
        // 修复：直接将匹配到的标签作为数组，不要先join再split
        const tags = [...txt.matchAll(/【([^【】]+)】/g)]
                     .map(m => m[1].trim());
        li.setAttribute('data-tags', tags.join('|')); // 正确：将数组join为管道符分隔的字符串
    });
}, 100);

/******************************************************************
 * 【7】修复点击事件（使用事件委托）
 ******************************************************************/
(function() {
    setTimeout(() => {
        // 修复：使用dv.container来查找元素，确保在正确的上下文中
        const wrap = dv.container.querySelector('#tagReportWrap');
        if (!wrap) return;

        // 事件委托：监听整个容器的点击
        const handler = (e) => {
            const tagLink = e.target.closest('.tag-filter');
            if (!tagLink) return;

            e.preventDefault();
            const tag = tagLink.dataset.tag;

            // 新增防抖逻辑
            clearTimeout(window._filterDebounce);
            window._filterDebounce = setTimeout(() => {
                const taskLis = wrap.querySelectorAll('#taskContainer li');
                const currentFilter = tag === 'All' ? null : tag;
                taskLis.forEach(li => {
                    li.style.display = currentFilter && !li.dataset.tags.includes(currentFilter)
                        ? 'none'
                        : '';
                });
            }, 50);
        };

        // 先移除旧监听器再添加新
        wrap.removeEventListener('click', handler);
        wrap.addEventListener('click', handler);
    }, 500);  // 延长等待时间确保DOM渲染完成
})();

// 修改：将 setTimeout 包裹在立即执行函数中，避免返回 Promise
(async () => {
    await new Promise(resolve => setTimeout(resolve, 500));
})();
```